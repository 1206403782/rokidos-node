
/*
 *  This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */

#ifndef __dbusxx__NativeBase_adaptor_h__ADAPTOR_MARSHAL_H
#define __dbusxx__NativeBase_adaptor_h__ADAPTOR_MARSHAL_H

#include <dbus-c++-1/dbus-c++/dbus.h>
#include <cassert>

namespace rokid {
namespace openvoice {

class NativeBase_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    NativeBase_adaptor()
    : ::DBus::InterfaceAdaptor("rokid.openvoice.NativeBase")
    {
        register_method(NativeBase_adaptor, GetInfo, _GetInfo_stub);
        register_method(NativeBase_adaptor, onCreate, _onCreate_stub);
        register_method(NativeBase_adaptor, onRestart, _onRestart_stub);
        register_method(NativeBase_adaptor, onRevival, _onRevival_stub);
        register_method(NativeBase_adaptor, onResume, _onResume_stub);
        register_method(NativeBase_adaptor, onPause, _onPause_stub);
        register_method(NativeBase_adaptor, onStop, _onStop_stub);
        register_method(NativeBase_adaptor, onDestroy, _onDestroy_stub);
        register_method(NativeBase_adaptor, onRapture, _onRapture_stub);
        register_method(NativeBase_adaptor, onEvent, _onEvent_stub);
        register_method(NativeBase_adaptor, onVoiceCommand, _onVoiceCommand_stub);
    }

    ::DBus::IntrospectedInterface *introspect() const 
    {
        static ::DBus::IntrospectedArgument GetInfo_args[] = 
        {
            { "info", "s", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onCreate_args[] = 
        {
            { "contex", "s", true },
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onRestart_args[] = 
        {
            { "contex", "s", true },
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onRevival_args[] = 
        {
            { "contex", "s", true },
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onResume_args[] = 
        {
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onPause_args[] = 
        {
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onStop_args[] = 
        {
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onDestroy_args[] = 
        {
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onRapture_args[] = 
        {
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onEvent_args[] = 
        {
            { "event", "s", true },
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument onVoiceCommand_args[] = 
        {
            { "asr", "s", true },
            { "nlp", "s", true },
            { "action", "s", true },
            { "ret", "b", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument StartAvtivity_args[] = 
        {
            { "appid", "s", true },
            { "contex", "s", true },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument SubFinish_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Finish_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod NativeBase_adaptor_methods[] = 
        {
            { "GetInfo", GetInfo_args },
            { "onCreate", onCreate_args },
            { "onRestart", onRestart_args },
            { "onRevival", onRevival_args },
            { "onResume", onResume_args },
            { "onPause", onPause_args },
            { "onStop", onStop_args },
            { "onDestroy", onDestroy_args },
            { "onRapture", onRapture_args },
            { "onEvent", onEvent_args },
            { "onVoiceCommand", onVoiceCommand_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod NativeBase_adaptor_signals[] = 
        {
            { "StartAvtivity", StartAvtivity_args },
            { "SubFinish", SubFinish_args },
            { "Finish", Finish_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty NativeBase_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface NativeBase_adaptor_interface = 
        {
            "rokid.openvoice.NativeBase",
            NativeBase_adaptor_methods,
            NativeBase_adaptor_signals,
            NativeBase_adaptor_properties
        };
        return &NativeBase_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual std::string GetInfo() = 0;
    virtual bool onCreate(const std::string& contex) = 0;
    virtual bool onRestart(const std::string& contex) = 0;
    virtual bool onRevival(const std::string& contex) = 0;
    virtual bool onResume() = 0;
    virtual bool onPause() = 0;
    virtual bool onStop() = 0;
    virtual bool onDestroy() = 0;
    virtual bool onRapture() = 0;
    virtual bool onEvent(const std::string& event) = 0;
    virtual bool onVoiceCommand(const std::string& asr, const std::string& nlp, const std::string& action) = 0;

public:

    /* signal emitters for this interface
     */
    void StartAvtivity(const std::string& arg1, const std::string& arg2)
    {
        ::DBus::SignalMessage sig("StartAvtivity");
        ::DBus::MessageIter wi = sig.writer();
        wi << arg1;
        wi << arg2;
        emit_signal(sig);
    }
    void SubFinish()
    {
        ::DBus::SignalMessage sig("SubFinish");
        emit_signal(sig);
    }
    void Finish()
    {
        ::DBus::SignalMessage sig("Finish");
        emit_signal(sig);
    }

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _GetInfo_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argout1 = GetInfo();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onCreate_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        bool argout1 = onCreate(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onRestart_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        bool argout1 = onRestart(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onRevival_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        bool argout1 = onRevival(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onResume_stub(const ::DBus::CallMessage &call)
    {
        bool argout1 = onResume();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onPause_stub(const ::DBus::CallMessage &call)
    {
        bool argout1 = onPause();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onStop_stub(const ::DBus::CallMessage &call)
    {
        bool argout1 = onStop();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onDestroy_stub(const ::DBus::CallMessage &call)
    {
        bool argout1 = onDestroy();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onRapture_stub(const ::DBus::CallMessage &call)
    {
        bool argout1 = onRapture();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onEvent_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        bool argout1 = onEvent(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _onVoiceCommand_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        std::string argin2; ri >> argin2;
        std::string argin3; ri >> argin3;
        bool argout1 = onVoiceCommand(argin1, argin2, argin3);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } 
#endif //__dbusxx__NativeBase_adaptor_h__ADAPTOR_MARSHAL_H
